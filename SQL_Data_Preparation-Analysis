# This script performs essential data cleaning, transformation, and initial exploratory analysis for the Cyclistic dataset.
# We're beginning by creating a new column to calculate the duration of each bike ride in minutes.
ALTER TABLE cyclistic.`full_year_data`
ADD `ride_length` INT(5)
    AS (TIMESTAMPDIFF(minute, started_at, ended_at))
    AFTER member_casual;

# Next, we're adding a column to identify the day of the week for each ride, with Sunday as '1' and Saturday as '7'.
ALTER TABLE cyclistic.`full_year_data`
ADD `day_of_week` INT(5)
    AS (DAYOFWEEK(started_at))
    AFTER ride_length;

# Let's add a column to extract the month from the start time of each ride.
ALTER TABLE cyclistic.`full_year_data`
ADD `month` INT(5)
    AS (MONTH(started_at))
    AFTER day_of_week;

# We'll also create a new column to specify the year for each ride.
ALTER TABLE cyclistic.`full_year_data`
ADD `year` INT(5)
    AS (YEAR(started_at))
    AFTER month;

# To ensure data quality, we're inspecting the dataset to identify any rides with a duration of zero minutes or less, which are likely data entry errors.
SELECT *
FROM cyclistic.full_year_data
WHERE ride_length <= 0;

# We're also checking for any missing values in the 'member_casual' column to ensure all records have a user type.
SELECT *
FROM cyclistic.full_year_data
WHERE member_casual IS NULL;

# Now we will remove the rows that have a ride duration of zero or less, as this data is not valid for our analysis.
DELETE FROM cyclistic.full_year_data
WHERE ride_length <= 0;

# This query calculates the total number of rides and the number of unique users in the dataset.
SELECT (COUNT (ride_id)) AS total_rides, COUNT (DISTINCT ride_id) AS unique_users
FROM
    cyclistic.`full_year_data`;

# Here, we're calculating key statistics for each day of the week, including the count of rides and the average, maximum, and minimum ride lengths, separated by member type.
SELECT day_of_week, member_casual, COUNT(*) AS num_of_rides,
       AVG(full_year_data.ride_length) AS Avg_ride_length,
       MAX(full_year_data.ride_length) AS Max_ride_length,
       MIN(full_year_data.ride_length) AS Min_ride_length
FROM  cyclistic.full_year_data
GROUP BY day_of_week, member_casual
ORDER BY day_of_week ASC;

# This query provides a summary of ride length statistics—average, maximum, and minimum—categorized by member versus casual riders.
SELECT member_casual,
       AVG(full_year_data.ride_length) AS Avg_ride_length,
       MAX(full_year_data.ride_length) AS Max_ride_length,
       MIN(full_year_data.ride_length) AS Min_ride_length
FROM cyclistic.full_year_data
GROUP BY member_casual;

# Lastly, we're analyzing ride patterns by month, finding the total number of rides and the average, maximum, and minimum ride lengths, grouped by month and member type.
SELECT month, member_casual, COUNT(*) AS num_of_rides,
       AVG(full_year_data.ride_length) AS Avg_ride_length,
       MAX(full_year_data.ride_length) AS Max_ride_length,
       MIN(full_year_data.ride_length) AS Min_ride_length
FROM  cyclistic.full_year_data
GROUP BY month, year, member_casual
ORDER BY month ASC;
